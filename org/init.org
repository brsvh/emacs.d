# Copyright (C) 2022-2024 Burgess Chang

# This file is part of emacs.d.

# emacs.d is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.

# emacs.d is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.

# You should have received a copy of the GNU General Public License
# along with emacs.d.  If not, see <https://www.gnu.org/licenses/>.

#+options: toc:nil num:nil
#+startup: noindent fnadjust
#+exclude_tags: nonexport
#+macro: kbd @@html:<kbd>@@ $1 @@html:</kbd>@@

#+title: GNU Emacs Init File
#+author: Burgess Chang
#+email: (concat bsc at-sign brsvh dot org)

* File header                                                :nonexport:

The tangled file will follow [[info:elisp#Library Headers]].

** Description

#+begin_src emacs-lisp
  ;;; init.el --- Init File -*- lexical-binding: t; -*-

  ;; Copyright (C) 2022-2024 Burgess Chang

  ;; Author: Burgess Chang <bsc@brsvh.org>
  ;; Keywords: internal
  ;; Package-Requires: ((emacs "29.1"))
  ;; URL: https://github.com/brsvh/emacs.d
  ;; Version: 0.50.0
#+end_src

** License

#+begin_src emacs-lisp
  ;; This file is part of emacs.d.

  ;; emacs.d is free software: you can redistribute it and/or modify it
  ;; under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.

  ;; emacs.d is distributed in the hope that it will be useful, but
  ;; WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  ;; General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with emacs.d.  If not, see <https://www.gnu.org/licenses/>.
#+end_src

** Introduction

#+begin_src emacs-lisp
  ;;; Commentary:

  ;; This file is the first loaded file after Emacs is started.
#+end_src

** Code

#+begin_src emacs-lisp
  ;;; Code:
#+end_src

** Dependencies

Ensure that the Early Init File[fn:1] has been loaded correctly.

#+begin_src emacs-lisp
  (require 'early-init
           (expand-file-name "early-init" user-emacs-directory)
           'noerror)
#+end_src

* Conventions

I maintain the stylistic consistency of the configuration file as it
grows, adhering to conventions for functions, variables, key bindings,
, file storage and ELPA management.

** Naming conventions

I adhere to a straightforward naming convention for functions and variables.

- Public functions and variables start with the prefix ~my-~.
- Private or internal functions and variables start with the prefix
  ~my--~.
- Interactive commands start with the prefix ~my/~.

** File conventions

The default pathways used for the storage of configuration files and
enduring data exhibit inconsistency across Emacs packages.  This issue
is not confined to third-party packages, but also extends to built-in
ones.

Some packages deposit these files directly in the ~user-emacs-directory~
or ~HOME~, or in a subdirectory of either, or even elsewhere.
Additionally, file names that fail to provide clarity regarding the
package responsible for their creation are occasionally employed.

Consequently, I undertake the management of these files independently,
adhering to the XDG Base Directory specification to the greatest extent
feasible.

I have classified the Emacs-related files into four distinct categories.

- Cache: Produced by Emacs Packages, relative to which user-specific
  non-essential data files should be stored.  They specify the location
  of storage via ~my-cache-directory~.
- Config: Crafted by me, their content is of significance to me.  They
  specify the location of storage via ~my-config-directory~.
- Data: Produced by Emacs Packages, relative to which user-specific data
  files should be stored.  They specify the location of storage via
  ~my-data-directory~.
- State: Produced by Emacs Packages, persist between sessions restarts,
  but that is not important or portable enough to the user that it
  should be stored as data file.  They specify the location of storage
  via ~my-state-directory~.

In reality, these variables are defined within ~early-init~[fn:1].

#+begin_src emacs-lisp :exports none
(defvar my-cache-directory)
(defvar my-config-directory)
(defvar my-data-directory)
(defvar my-state-directory)
#+end_src

** ELPA management conventions

I used ~twist~[fn:2] for the management of my used Emacs Lisp packages.
It provide a pure and reproducible method to package my configuration
and all dependent packages into a singular Nix package.  Without
incurring substantial additional costs, I essentially do not require the
composition of any Emacs Lisp code.  My Emacs configuration appears as
though it is employing the built-in ~package~.

Furthermore, I employ the ~use-package~ macro to manage package
configurations in an isolated manner, it provided by the package
~use-package~ of the same name.

When configuration alterations are necessitated, by executing an app
named ~lock~, all package inputs specified in the configuration via the
/:ensure/ keyword are added to the =elpa= directory.  This is achieved
through the parsing of the configuration by the ~use-package~ parser
provided by ~twist~.

#+begin_src shell
nix run .#lock --impure
#+end_src

Similarly, by executing an app named ~update~, all inputs in the
=elpa= directory are updated.

#+begin_src shell
nix run .#update --impure
#+end_src

*** Simple hacking on ~use-package~

As I use the parser provided by ~twist~ to find the packages that need
to be ensured, some keyword handlers may do some superfluous operations.
Adhering to the principle of cleanliness, I make simple modifications to
them.

#+begin_src emacs-lisp
  (use-package use-package
    :preface
    (defun my--use-package-fake-ensure-package (&rest _)
      "Do nothing when the need for ensures package installation."
      t)

    (defun my--use-package-fake-pin-package (&rest _)
      "Do nothing when pin package to archive."
      t)
    :init
    (setq use-package-hook-name-suffix nil)

    (setq use-package-ensure-function
          'my--use-package-fake-ensure-package)
    :config
    (advice-add 'use-package-pin-package
                :override
                'my--use-package-fake-pin-package))
#+end_src

As you see in the code above, the /:ensure/ keyword of ~use-package~
conventionally employs ~package~ to verify the installation status of
the package.  In reality, I am currently utilizing ~twist~ to manage all
ELPA, which results in the execution of the superfluous
~package-refresh-contents~ during the startup process, circumventing
this occurrence.  For the same reason, it also overrides the handler of
/:pin/ keyword.

When employing the /:hook/ keyword to delegate a task to the hook,
~use-package~ will use an abbreviated hook name.  To illustrate,
~c-mode-hook~ is truncated as ~c-mode~, and ~emacs-startup-hook~ is
truncated as ~emacs-startup~.  Given my occasional propensity for
oversight, which may lead to inconsistencies, it is imperative to ensure
that ~use-package~ invariably employs the accurate hook name.

** Keybinding conventions

For all commands, both those I have created and those from other
packages, I bind them to {{{kbd(C-c)}}} for invocation via a sequence of
key combinations.

I have defined a keymap, denoted as ~ctl-c-map~, analogous to
~ctl-x-map~, binding all commands with {{{kbd(C-c)}}} as a prefix key to
it.

#+begin_src emacs-lisp
  (defvar ctl-c-map (make-keymap)
    "Default keymap for C-c commands.")

  (keymap-set global-map "C-c" ctl-c-map)
#+end_src

Typically, the major mode command is bound to a key under the prefix key
{{{kbd(C-c)}}} and necessitates holding down {{{kbd(Control)}}}.  For
instance, {{{kbd(C-c C-e)}}} is bound to ~elisp-eval-buffer~ in
~emacs-lisp-mode~, {{{kbd(C-c C-l)}}} is bound to ~org-insert-link~ in
~org-mode~, and so forth.

Consequently, I bind the commands I require to the letter keys with
{{{kbd(C-c)}}} as the prefix key. These letter keys are also employed
for categorization purposes.

** Init Conventions

The [[info:elisp#Startup Summary][startup]] of Emacs is rather
intricate, and I harbor certain compulsions towards controlling this
process.  I anticipate that the most of Minor Modes should use hooks to
regulate their activation and deactivation, hence I have some
conventions for managing the startup process.

All settings related to the User Interface during the initialization
process will be activated via ~emacs-startup-hook~, otherwise, they will
be activated through ~after-init-hook~.

#+begin_src emacs-lisp
  (use-package startup
    :no-require t
    :defines
    (after-init-hook emacs-startup-hook))
#+end_src

* Libraries                                                  :nonexport:

** ~cl-lib~

~cl-lib~ is a forward compatibility package in Emacs, it added Common
Lisp-like features to Emacs Lisp.  It enhances Emacs Lisp programming by
adding numerous Common Lisp functions and control structures.

#+begin_src emacs-lisp
  (use-package cl-lib)
#+end_src

* Customization system

Emacs is a real-time, extensible, and customizable editor.  Its
customization system, *Easy Customize*, allows users to modify existing
commands or add new ones. Users can navigate through a list of settings,
edit and set their values, and save them permanently.

** Easy Customization Interface

Despite my abstention from utilizing the Easy Customization Interface of
Emacs, certain packages surreptitiously employ it unbeknownst to me.  In
pursuit of maintaining the integrity of the ~user-init-file~ and my
configuration file, devoid of auto-generated content, I opt to preserve
customizations in an alternative location, distinct from my
initialization file.

#+begin_src emacs-lisp
  (setq custom-file (expand-file-name "custom.el" my-state-directory))

  (when (file-exists-p custom-file)
    (load custom-file nil 'nomessage))
#+end_src

* User interface

The inherent interface of Emacs exudes a vintage and traditional aura,
which, as a youthful individual, I find less appealing.  My preference
leans towards a more contemporary aesthetic.

** Default frame layout

Emacs facilitates operations on both graphical and non-graphical frames.
The default frame layout exhibits a menu bar, tool bar, and vertical
scroll bar.  However, in the character-only frame, the tool bar and
vertical scroll bar are absent.

While the menu bar, tool bar, and scroll bar serve practical purposes,
my operational flow is predominantly keyboard-centric.  Given their
infrequent usage and their propensity to cause distractions, I have
chosen to disable them.

An additional, albeit less significant, rationale is that these bars are
initialized prior to the evaluation of the init file (post
~before-init-hook~), which inadvertently decelerates Emacs startup.
Disabling them consequently enhances Emacs' speed, of course, it needs
to be done in ~early-init~[fn:1].

#+begin_src emacs-lisp
  (use-package emacs
    :no-require t
    :init
    (menu-bar-mode -1)
    (tool-bar-mode -1))

  (use-package scroll-bar
    :init
    (scroll-bar-mode -1))
#+end_src

** Default startup screen

Emacs exhibits a *\*GNU Emacs\** buffer, which I find to be of limited
utility.  As an alternative, I employ the *\*scratch\** buffer as the
default screen, ensuring to meticulously cleanse its content and the
echo area.

#+begin_src emacs-lisp
  (use-package startup
    :no-require t
    :init
    (setq inhibit-startup-screen t
          inhibit-startup-echo-area-message t
          initial-scratch-message nil
          initial-major-mode 'fundamental-mode))
#+end_src

** Accessible theme

Emacs' inherent theme is somewhat lackluster, lacking the polished and
lustrous appearance that typically appeals to novices, often resulting
in a superficial and unfavorable initial impression of the
system. Subsequently, I use Modus Themes[fn:3] that enhances Emacs'
aesthetic appeal, rendering it more user-friendly.

#+begin_src emacs-lisp
  (use-package modus-themes
    :ensure modus-themes
    :config
    (setq modus-themes-custom-auto-reload t
          modus-themes-bold-constructs t
          modus-themes-italic-constructs t
          modus-themes-mixed-fonts t
          modus-themes-prompts '(bold)
          modus-themes-completions '((matches . (extrabold))
                                     (selection . (semibold
                                                   fitalic
                                                   text-also)))
          modus-themes-org-blocks 'tinted-background
          modus-themes-headings '((1 . (1.5 extrabold))
                                  (2 . (1.3 heavy))
                                  (3 . (1.2 bold))
                                  (t . (1.1 semibold))))

    (if (display-graphic-p)
        (load-theme 'modus-operandi-tinted :no-confirm)
      (load-theme 'modus-vivendi-tinted :no-confirm)))
#+end_src

As you may have noticed, I have used a rudimentary configuration of
Modus Themes.  When utilizing the graphical interface of Emacs, I prefer
a light theme, whereas in other scenarios, I opt for a dark theme.
These other scenarios typically involve interfaces that solely support
characters, such as remote access via SSH or launching Emacs in a
terminal.  Predominantly, I desire a more conspicuous style for my Emacs
interface, hence you observe my activation of extensive italic and bold
support.

Furthermore, there is an additional rectification wherein I have ensured
uniformity between the background color of the current line and the
current line number.  However, this rectification lacks elegance.
Ideally, it should use the overlay
~modus-themes-common-palette-overrides~ provided by Modus Themes for
adjustments, but it is currently non-functional and awaits future
rectification.

#+begin_src emacs-lisp
  (defun my--modus-themes-enale-p ()
    "Return t if current theme is belong to Modus Themes, else nil."
    (cl-some #'(lambda (theme)
                 (member theme '(modus-operandi
                                 modus-operandi-tinted
                                 modus-vivendi
                                 modus-vivendi-tinted)))
             custom-enabled-themes))

  (use-package display-line-numbers
    :config
    (defun my--reset-modus-themes-line-number-face ()
      "Use the more subtle line number background color."
      (when (my--modus-themes-enale-p)
        (let* ((cline 'line-number-current-line)
               (oline 'line-number)
               (proper-bg (face-attribute oline :background)))
          (set-face-attribute cline nil :background proper-bg))))
    :hook
    (display-line-numbers-mode-hook
     .
     my--reset-modus-themes-line-number-face))

  (use-package hl-line
    :config
    (defun my--reset-modus-themes-line-number-face-when-highlight ()
      "Use the more subtle line number background color."
      (when (my--modus-themes-enale-p)
        (let* ((cline 'line-number-current-line)
               (hline 'hl-line)
               (oline 'line-number)
               (origin-bg (face-attribute oline :background))
               (proper-bg (face-attribute hline :background)))
          (if hl-line-mode
              (setq proper-bg (face-attribute hline :background))
            (setq proper-bg origin-bg))
          (set-face-attribute cline nil :background proper-bg))))
    :hook
    (hl-line-mode-hook
     .
     my--reset-modus-themes-line-number-face-when-highlight))
#+end_src

* Multilingual Environment

As a polyglot (it may not qualify as such, but I want to be.), it is
only natural for me to use Emacs for editing text in various languages.
Fortuitously, Emacs' multilingual environment extends support to
virtually all coding systems.

** UTF-8

Within the realm of Linux, UTF-8 is the superior encoding methodology
for Unicode.  Consequently, I default to employing UTF-8, barring
instances where the encoding is explicitly delineated otherwise.

#+begin_src emacs-lisp
  (use-package mule-cmds
    :no-require t
    :init
    (set-default-coding-systems 'utf-8)
    (set-language-environment "utf-8")
    (prefer-coding-system 'utf-8))
#+end_src

* Completion

The completion feature in Emacs significantly enhances my interaction
with the Emacs.  Primarily, Emacs offers two types of completion:

- Input completion, which provides completion when entering input in the
  minibuffer.
- Text completion, which provides completion during text editing in the
  buffer.

Given the substantial differences in the scenarios for these two types
of completion, I refrain from employing a uniform completion interaction
method for both.

** Input completion

My choice is to provided input completion support with ~vertico~ [fn:4],
which is a performant, minimalistic vertical completion UI for Emacs.
It reuses built-in facilities for full compatibility with Emacs'
completion commands and tables.

It can be effortlessly enabled by activating *Vertico Mode*.  Of course,
additional configurations are indispensable for catering to personalized
requirements.

Upon the initiation of *Vertico Mode*, a minibuffer of immutable
dimensions is exhibited during the completion process.  My inclination,
however, is towards a flexible height contingent upon the quantity of
remaining candidates.

An additional facet necessitates refinement.  Upon navigating to the
last candidate, I require assistance to expediently back to the top.
Consequently, I enable the cyclical functionality of ~vertico-next~ and
~vertico-previous~.

By default, ~find-file~ initiates the opening of files residing in the
current directory, rendering the modification of the ~find-file~ path a
prevalent procedure.  Regrettably, the default setting permits the
deletion of a solitary character at a time, a process that is not only
cumbersome but also exhausts my patience.  Fortunately, ~vertico~
incorporates an extension, ~vertico-directory~, which proffers commands
capable of eliminating multiple characters in the path simultaneously by
word.  I have elected to assign these commands to the
{{{kbd(<backspace>)}}} key.

And a litte help, I set *Vertico Mouse Mode* to use the mouse to select
the candidates.

#+begin_src emacs-lisp
  (use-package vertico
    :ensure vertico
    :pin gnu
    :config
    (setq vertico-resize t)

    (setq vertico-cycle t)
    :hook
    (emacs-startup-hook . vertico-mode)
    (vertico-mode-hook . vertico-mouse-mode)
    :bind
    (:map vertico-map
     ("<return>" . vertico-directory-enter)
     ("<backspace>" . vertico-directory-delete-char)
     ("M-<backspace>" . vertico-directory-delete-word)))
#+end_src

*** Show mariginalia of completions

Marginalia are marks or annotations placed at the margin of the page of
a book or in this case helpful colorful annotations placed at the margin
of the minibuffer for your completion candidates.[fn:5]

I use it to glance at docstring, the values of variables, and even file
permissions.

#+begin_src emacs-lisp
  (use-package marginalia
    :ensure marginalia
    :pin gnu
    :config
    (setq marginalia-align 'right)
    :hook
    (emacs-startup-hook . marginalia-mode))
#+end_src

* Writing

Emacs is an indispensable companion for authors, the abundant extensions
from the Emacs community and the extensibility of Emacs itself proffer
boundless opportunities for writing.

However, the most of these are not ready to use out of the box, or
rather, they are not enabled by default.  At the same time, I do not
wish to enable them as global settings.  Therefore, you will see that
most of my writing configurations are tailored for those text editing
modes derived from *Text Mode* and *Outline Mode*.

During my writing, I desire Emacs to highlight my current position
within the buffer, which aids in visually pinpointing the editing
location.  Contrary to programming, I am indifferent to the absolute
position of the editing location during writing, referring here to the
file path and row-column coordinates; I merely require the current
editing line to be highlighted.

#+begin_src emacs-lisp
  (use-package hl-line
    :commands
    (hl-line-mode))

  (use-package outline
    :hook
    (outline-mode-hook . hl-line-mode))

  (use-package text-mode
    :hook
    (text-mode-hook . hl-line-mode))
#+end_src

Emacs supports a variety of line-folding methods[fn:6], including:

- *Hard Wrap* ：Modes such as AutoFillMode insert a line ending after
  the last word that occurs before the value of option ~fill-column~ (a
  column number).
- *Soft Wrap* ：Modes such as VisualFillColumn (in concert with
  VisualLineMode) wrap a line after the last word before ~fill-column~,
  but ultimately they do not alter the buffer text.  Such *soft*
  wrapping is essentially a display effect.
- *Default Wrap* : Emacs wraps a line that reaches the window width,
  except at a word boundary.  The buffer text is not changed.

In the most of my cases, I employ the *Soft Wrap* method.

#+begin_src emacs-lisp
  (use-package simple
    :commands
    (visual-line-mode))

  (use-package outline
    :hook
    (outline-mode-hook . visual-line-mode))

  (use-package text-mode
    :hook
    (text-mode-hook . visual-line-mode))
#+end_src

* Programming

Emacs is an exceptionally potent programming environment. However, it
necessitates meticulous configuration; otherwise, its functioning will
be subpar.  Let me to tailor Emacs to accommodate all the programming
languages I used.

** Emacs Lisp

When crafting Emacs Lisp programs, we often write and invoke numerous
macros.  Merely contemplating to decipher the code generated by macros
is insufficient.  I used ~pp-macroexpand-last-sexp~ to preview the
current macro expansion.  For convenience, it is bound to the {{{kbd(C-c
C-v)}}} key in *Emacs Lisp Mode*.  Here, {{{kbd(v)}}} implies verbose.

#+begin_src emacs-lisp
  (use-package pp
    :bind
    (:map emacs-lisp-mode-map
     ("C-c C-v" . pp-macroexpand-last-sexp)))
#+end_src

** Nix

By default, Emacs does not furnish *Nix Mode*.  Consequently, it
necessitates installation from ELPA, followed by automatic activation
predicated on the extension name.

#+begin_src emacs-lisp
  (use-package nix-mode
    :ensure nix-mode
    :mode
    ("\\.nix\\'" . nix-mode))
#+end_src

* File footer

#+begin_src emacs-lisp
  (provide 'init)
  ;;; init.el ends here
#+end_src

* Footnotes

[fn:1] early-init, [[file:early-init.org]]

[fn:2] Twist, https://github.com/emacs-twist/twist.nix

[fn:3] Modus Themes, https://protesilaos.com/emacs/modus-themes

[fn:4] Vertico, https://github.com/minad/vertico

[fn:5] Marginalia, https://github.com/minad/marginalia

[fn:6] Line Wrap, https://www.emacswiki.org/emacs/LineWrap
